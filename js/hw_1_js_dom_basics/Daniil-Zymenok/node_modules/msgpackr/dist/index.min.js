(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports):"function"==typeof define&&define.amd?define(["exports"],b):(a=a||self,b(a.msgpackr={}))})(this,function(a){'use strict';var b=Math.floor;function c(){try{if(!K.trusted&&!R){let a=E.sharedLength||0;a<E.length&&(E.length=a)}let a=e();if(G&&(// bundled strings to skip past
J=G.postBundlePosition),J==D)E.restoreStructures&&d(),E=null,C=null,H&&(H=null);else if(J>D)// over read
throw new Error("Unexpected end of MessagePack data");else if(!R)throw new Error("Data read, but end of buffer not reached "+JSON.stringify(a).slice(0,100));// else more to read, but we are reading sequentially, so don't clear source yet
return a}catch(a){throw E.restoreStructures&&d(),r(),(a instanceof RangeError||a.message.startsWith("Unexpected end of buffer")||J>D)&&(a.incomplete=!0),a}}function d(){for(let a in E.restoreStructures)E[a]=E.restoreStructures[a];E.restoreStructures=null}function e(){let a=C[J++];if(160>a){if(!(128>a)){if(!(144>a)){a-=144;let b=Array(a);for(let c=0;c<a;c++)b[c]=e();return b}if(a-=128,K.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[p()]=e();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(e(),e());return b}}else if(64>a)return a;else{let b=E[63&a]||K.getStructures&&g()[63&a];return b?(b.read||(b.read=f(b,63&a)),b.read()):a}}else if(192>a){// fixstr
let b=a-160;if(M>=J)return F.slice(J-L,(J+=b)-L);if(0==M&&140>D){// for small blocks, avoiding the overhead of the extract call is helpful
let a=16>b?l(b):k(b);if(null!=a)return a}return W(b)}else{let b;switch(a){case 192:return null;case 193:return G?(b=e(),0<b?G[1].slice(G.position1,G.position1+=b):G[0].slice(G.position0,G.position0-=b)):Q;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:if(b=C[J++],void 0===b)throw new Error("Unexpected end of buffer");return n(b);case 197:return b=I.getUint16(J),J+=2,n(b);case 198:return b=I.getUint32(J),J+=4,n(b);case 199:// ext 8
return o(C[J++]);case 200:return b=I.getUint16(J),J+=2,o(b);case 201:return b=I.getUint32(J),J+=4,o(b);case 202:if(b=I.getFloat32(J),2<K.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let a=da[(127&C[J])<<1|C[J+1]>>7];return J+=4,(a*b+(0<b?.5:-.5)>>0)/a}return J+=4,b;case 203:return b=I.getFloat64(J),J+=8,b;// uint handlers
case 204:return C[J++];case 205:return b=I.getUint16(J),J+=2,b;case 206:return b=I.getUint32(J),J+=4,b;case 207:return K.int64AsNumber?(b=4294967296*I.getUint32(J),b+=I.getUint32(J+4)):b=I.getBigUint64(J),J+=8,b;// int handlers
case 208:return I.getInt8(J++);case 209:return b=I.getInt16(J),J+=2,b;case 210:return b=I.getInt32(J),J+=4,b;case 211:return K.int64AsNumber?(b=4294967296*I.getInt32(J),b+=I.getUint32(J+4)):b=I.getBigInt64(J),J+=8,b;case 212:if(b=C[J++],114==b)return aa(63&C[J++]);else{let a=N[b];if(a)return a.read?(J++,a.read(e())):a.noBuffer?(J++,a()):a(C.subarray(J,++J));throw new Error("Unknown extension "+b)}case 213:return b=C[J],114==b?(J++,aa(63&C[J++],C[J++])):o(2);case 214:// fixext 4
return o(4);case 215:// fixext 8
return o(8);case 216:// fixext 16
return o(16);case 217:return b=C[J++],M>=J?F.slice(J-L,(J+=b)-L):X(b);case 218:return b=I.getUint16(J),J+=2,M>=J?F.slice(J-L,(J+=b)-L):Y(b);case 219:return b=I.getUint32(J),J+=4,M>=J?F.slice(J-L,(J+=b)-L):Z(b);case 220:return b=I.getUint16(J),J+=2,i(b);case 221:return b=I.getUint32(J),J+=4,i(b);case 222:return b=I.getUint16(J),J+=2,j(b);case 223:return b=I.getUint32(J),J+=4,j(b);default:// negative int
if(224<=a)return a-256;if(void 0===a){let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}throw new Error("Unknown MessagePack token "+a);}}}function f(a,b){function c(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(c.count++>S){let c=a.read=new Function("r","return function(){return {"+a.map(a=>U.test(a)?a+":r()":"["+JSON.stringify(a)+"]:r()").join(",")+"}}")(e);return 0===a.highByte&&(a.read=V(b,a.read)),c();// second byte is already read, if there is one so immediately read object
}let d={};for(let b,c=0,f=a.length;c<f;c++)b=a[c],d[b]=e();return d}return c.count=0,0===a.highByte?V(b,c):c}function g(){let a=q(()=>(C=null,K.getStructures()));return E=K._mergeStructures(a,E)}function h(a){let b;if(16>a&&(b=l(a)))return b;if(64<a&&B)return B.decode(C.subarray(J,J+=a));const c=J+a,d=[];for(b="";J<c;){const a=C[J++];if(0==(128&a))d.push(a);else if(192==(224&a)){// 2 bytes
const b=63&C[J++];d.push((31&a)<<6|b)}else if(224==(240&a)){// 3 bytes
const b=63&C[J++],c=63&C[J++];d.push((31&a)<<12|b<<6|c)}else if(240==(248&a)){// 4 bytes
const b=63&C[J++],c=63&C[J++],e=63&C[J++];let f=(7&a)<<18|b<<12|c<<6|e;65535<f&&(f-=65536,d.push(55296|1023&f>>>10),f=56320|1023&f),d.push(f)}else d.push(a);4096<=d.length&&(b+=$.apply(String,d),d.length=0)}return 0<d.length&&(b+=$.apply(String,d)),b}function i(a){let b=Array(a);for(let c=0;c<a;c++)b[c]=e();return b}function j(a){if(K.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[p()]=e();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(e(),e());return b}}function k(a){let b=J,c=Array(a);for(let d=0;d<a;d++){const a=C[J++];if(0<(128&a))return void(J=b);c[d]=a}return $.apply(String,c)}function l(p){if(4>p){if(!(2>p)){let d=C[J++],a=C[J++];if(0<(128&d)||0<(128&a))return void(J-=2);if(3>p)return $(d,a);let b=C[J++];return 0<(128&b)?void(J-=3):$(d,a,b)}if(0===p)return"";else{let b=C[J++];return 1<(128&b)?void(J-=1):$(b)}}else{let q=C[J++],a=C[J++],b=C[J++],c=C[J++];if(0<(128&q)||0<(128&a)||0<(128&b)||0<(128&c))return void(J-=4);if(6>p){if(4===p)return $(q,a,b,c);else{let d=C[J++];return 0<(128&d)?void(J-=5):$(q,a,b,c,d)}}else if(8>p){let d=C[J++],e=C[J++];if(0<(128&d)||0<(128&e))return void(J-=6);if(7>p)return $(q,a,b,c,d,e);let f=C[J++];return 0<(128&f)?void(J-=7):$(q,a,b,c,d,e,f)}else{let d=C[J++],e=C[J++],f=C[J++],g=C[J++];if(0<(128&d)||0<(128&e)||0<(128&f)||0<(128&g))return void(J-=8);if(10>p){if(8===p)return $(q,a,b,c,d,e,f,g);else{let h=C[J++];return 0<(128&h)?void(J-=9):$(q,a,b,c,d,e,f,g,h)}}else if(12>p){let h=C[J++],i=C[J++];if(0<(128&h)||0<(128&i))return void(J-=10);if(11>p)return $(q,a,b,c,d,e,f,g,h,i);let j=C[J++];return 0<(128&j)?void(J-=11):$(q,a,b,c,d,e,f,g,h,i,j)}else{let h=C[J++],i=C[J++],j=C[J++],k=C[J++];if(0<(128&h)||0<(128&i)||0<(128&j)||0<(128&k))return void(J-=12);if(!(14>p)){let l=C[J++],m=C[J++];if(0<(128&l)||0<(128&m))return void(J-=14);if(15>p)return $(q,a,b,c,d,e,f,g,h,i,j,k,l,m);let n=C[J++];return 0<(128&n)?void(J-=15):$(q,a,b,c,d,e,f,g,h,i,j,k,l,m,n)}if(12===p)return $(q,a,b,c,d,e,f,g,h,i,j,k);else{let l=C[J++];return 0<(128&l)?void(J-=13):$(q,a,b,c,d,e,f,g,h,i,j,k,l)}}}}}function m(){let a,b=C[J++];if(192>b)// fixstr
a=b-160;else switch(b){case 217:a=C[J++];break;case 218:a=I.getUint16(J),J+=2;break;case 219:a=I.getUint32(J),J+=4;break;default:throw new Error("Expected string");}return h(a)}function n(a){return K.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(C,J,J+=a):C.subarray(J,J+=a)}function o(a){let b=C[J++];if(N[b])return N[b](C.subarray(J,J+=a));throw new Error("Unknown extension type "+b)}function p(){let a=C[J++];if(160<=a&&192>a){if(a-=160,M>=J)// if it has been extracted, must use it (and faster anyway)
return F.slice(J-L,(J+=a)-L);if(!(0==M&&180>D))return W(a)}else return J--,e();let b,c=4095&(a<<5^(1<a?I.getUint16(J):0<a?C[J]:0)),d=_[c],f=J,g=J+a-3,h=0;if(d&&d.bytes==a){for(;f<g;){if(b=I.getUint32(f),b!=d[h++]){f=1879048192;break}f+=4}for(g+=3;f<g;)if(b=C[f++],b!=d[h++]){f=1879048192;break}if(f===g)return J=f,d.string;g-=3,f=J}for(d=[],_[c]=d,d.bytes=a;f<g;)b=I.getUint32(f),d.push(b),f+=4;for(g+=3;f<g;)b=C[f++],d.push(b);// for small blocks, avoiding the overhead of the extract call is helpful
let j=16>a?l(a):k(a);return null==j?d.string=W(a):d.string=j}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function q(a){let b=D,c=J,d=L,e=M,f=F,g=H,h=G,i=new Uint8Array(C.slice(0,D)),j=E,k=E.slice(0,E.length),l=K,m=R,n=a();return D=b,J=c,L=d,M=e,F=f,H=g,G=h,C=i,R=m,E=j,E.splice(0,E.length,...k),K=l,I=new DataView(C.buffer,C.byteOffset,C.byteLength),n}function r(){C=null,H=null,E=null}function s(a){N[a.type]=a.unpack?a.unpack:a}function t(a,b,c){let d=a.byteLength;if(256>d+1){var{target:e,position:f}=c(4+d);e[f++]=199,e[f++]=d+1}else if(65536>d+1){var{target:e,position:f}=c(5+d);e[f++]=200,e[f++]=d+1>>8,e[f++]=255&d+1}else{var{target:e,position:f,targetView:g}=c(7+d);// plus one for the type byte
e[f++]=201,g.setUint32(f,d+1),f+=4}// "t" for typed array
e[f++]=116,e[f++]=b,e.set(new Uint8Array(a.buffer,a.byteOffset,a.byteLength),f)}function u(a,b){let c=a.byteLength;var d,e;if(256>c){var{target:d,position:e}=b(c+2);d[e++]=196,d[e++]=c}else if(65536>c){var{target:d,position:e}=b(c+3);d[e++]=197,d[e++]=c>>8,d[e++]=255&c}else{var{target:d,position:e,targetView:f}=b(c+5);d[e++]=198,f.setUint32(e,c),e+=4}d.set(a,e)}function v(a,b,c,d){let e=a.length;return 1===e?b[c++]=212:2===e?b[c++]=213:4===e?b[c++]=214:8===e?b[c++]=215:16===e?b[c++]=216:256>e?(b[c++]=199,b[c++]=e):65536>e?(b[c++]=200,b[c++]=e>>8,b[c++]=255&e):(b[c++]=201,b[c++]=e>>24,b[c++]=255&e>>16,b[c++]=255&e>>8,b[c++]=255&e),b[c++]=d,b.set(a,c),c+=e,c}function w(a,b){// insert the ids that need to be referenced for structured clones
let c,d=6*b.length,e=a.length-d;for(b.sort((c,a)=>c.offset>a.offset?1:-1);c=b.pop();){let b=c.offset,f=c.id;a.copyWithin(b+d,b,e),d-=6;let g=b+d;// 'i'
a[g++]=214,a[g++]=105,a[g++]=f>>24,a[g++]=255&f>>16,a[g++]=255&f>>8,a[g++]=255&f,e=b}return a}function x(a,b){if(0<xa.length){ua.setUint32(xa.position+a,wa-xa.position-a);let c=xa;xa=null,b(c[0]),b(c[1])}}function y(a){if(a.Class){if(!a.pack&&!a.write)throw new Error("Extension has no pack or write function");if(a.pack&&!a.type)throw new Error("Extension has no type (numeric code to identify the extension)");na.unshift(a.Class),ma.unshift(a)}s(a)}function*z(a,b){const c=new za(b);for(const d of a)yield c.pack(d)}async function*A(a,b){const c=new za(b);for await(const d of a)yield c.pack(d)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - unpackr options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */var B;try{B=new TextDecoder}catch(a){}var C,D,E,F,G,H,I,J=0,K={},L=0,M=0,N=[],O={useRecords:!1,mapsAsObjects:!0};class P{}const Q=new P;Q.name="MessagePack 0xC1";var R=!1,S=2;try{new Function("")}catch(a){// if eval variants are not supported, do not create inline object readers ever
S=1/0}class T{constructor(a){a&&(!1===a.useRecords&&a.mapsAsObjects===void 0&&(a.mapsAsObjects=!0),a.sequential&&!1!==a.trusted&&(a.trusted=!0,!a.structures&&!1!=a.useRecords&&(a.structures=[],!a.maxSharedStructures&&(a.maxSharedStructures=0))),a.structures?a.structures.sharedLength=a.structures.length:a.getStructures&&((a.structures=[]).uninitialized=!0,a.structures.sharedLength=0)),Object.assign(this,a)}unpack(a,b){if(C)// re-entrant execution, save the state and restore it after we do this unpack
return q(()=>(r(),this?this.unpack(a,b):T.prototype.unpack.call(O,a,b)));D=-1<b?b:a.length,J=0,M=0,F=null,G=null,C=a;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{I=a.dataView||(a.dataView=new DataView(a.buffer,a.byteOffset,a.byteLength))}catch(b){if(C=null,a instanceof Uint8Array)throw b;throw new Error("Source must be a Uint8Array or Buffer but was a "+(a&&"object"==typeof a?a.constructor.name:typeof a))}if(this instanceof T){if(K=this,this.structures)return E=this.structures,c();(!E||0<E.length)&&(E=[])}else K=O,(!E||0<E.length)&&(E=[]);return c()}unpackMultiple(a,b){let d,e=0;try{R=!0;let f=a.length,g=this?this.unpack(a,f):ea.unpack(a,f);if(b){for(b(g);J<f;)if(e=J,!1===b(c()))return;}else{for(d=[g];J<f;)e=J,d.push(c());return d}}catch(a){throw a.lastPosition=e,a.values=d,a}finally{R=!1,r()}}_mergeStructures(a,b){a=a||[];for(let c,d=0,e=a.length;d<e;d++)c=a[d],c&&(c.isShared=!0,32<=d&&(c.highByte=d-32>>5));for(let c in a.sharedLength=a.length,b||[])if(0<=c){let d=a[c],e=b[c];e&&(d&&((a.restoreStructures||(a.restoreStructures=[]))[c]=d),a[c]=e)}return this.structures=a}decode(a,b){return this.unpack(a,b)}}const U=/^[a-zA-Z_$][a-zA-Z\d_$]*$/,V=(a,b)=>function(){let c=C[J++];if(0===c)return b();let d=32>a?-(a+(c<<5)):a+(c<<5),e=E[d]||g()[d];if(!e)throw new Error("Record id is not defined for "+d);return e.read||(e.read=f(e,a)),e.read()};var W=h,X=h,Y=h,Z=h;var $=String.fromCharCode,_=Array(4096);const aa=(a,b)=>{var c=e();let d=a;void 0!==b&&(a=32>a?-((b<<5)+a):(b<<5)+a,c.highByte=b);let g=E[a];return g&&g.isShared&&((E.restoreStructures||(E.restoreStructures=[]))[a]=g),E[a]=c,c.read=f(c,d),c.read()};N[0]=()=>{},N[0].noBuffer=!0,N[101]=()=>{let a=e();return(globalThis[a[0]]||Error)(a[1])},N[105]=()=>{// id extension (for structured clones)
let a=I.getUint32(J-4);H||(H=new Map);let b,c=C[J];b=144<=c&&160>c||220==c||221==c?[]:{};let d={target:b};// a placeholder object
H.set(a,d);let f=e();// read the next value as the target object to id
return d.used?Object.assign(b,f):(d.target=f,f);// no cycle, can just use the returned read object
},N[112]=()=>{// pointer extension (for structured clones)
let a=I.getUint32(J-4),b=H.get(a);return b.used=!0,b.target},N[115]=()=>new Set(e());const ba=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(a=>a+"Array");N[116]=a=>{let b=a[0],c=ba[b];if(!c)throw new Error("Could not find typed array for code "+b);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new globalThis[c](Uint8Array.prototype.slice.call(a,1).buffer)},N[120]=()=>{let a=e();return new RegExp(a[0],a[1])};const ca=[];N[98]=a=>{let b=(a[0]<<24)+(a[1]<<16)+(a[2]<<8)+a[3],c=J;return J+=b-a.length,G=ca,G=[m(),m()],G.position0=0,G.position1=0,G.postBundlePosition=J,J=c,e()},N[255]=a=>4==a.length?new Date(1e3*(16777216*a[0]+(a[1]<<16)+(a[2]<<8)+a[3])):8==a.length?new Date(((a[0]<<22)+(a[1]<<14)+(a[2]<<6)+(a[3]>>2))/1e6+1e3*(4294967296*(3&a[3])+16777216*a[4]+(a[5]<<16)+(a[6]<<8)+a[7])):12==a.length?new Date(((a[0]<<24)+(a[1]<<16)+(a[2]<<8)+a[3])/1e6+1e3*((128&a[4]?-281474976710656:0)+1099511627776*a[6]+4294967296*a[7]+16777216*a[8]+(a[9]<<16)+(a[10]<<8)+a[11])):new Date("invalid");const da=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let c=0;256>c;c++)da[c]=+("1e"+b(45.15-.30103*c));var ea=new T({useRecords:!1});const fa=ea.unpack,ga=ea.unpackMultiple,ha=ea.unpack,ia={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let ja,ka=new Float32Array(1),la=new Uint8Array(ka.buffer,0,4);try{ja=new TextEncoder}catch(a){}let ma,na;const oa="undefined"!=typeof Buffer,pa=oa?function(a){return Buffer.allocUnsafeSlow(a)}:Uint8Array,qa=oa?Buffer:Uint8Array,ra=oa?4294967296:2144337920;let sa,ta,ua,va,wa=0,xa=null;const ya=Symbol("record-id");class za extends T{constructor(a){super(a),this.offset=0;let b,c,d,e,f=0,g=qa.prototype.utf8Write?function(a,b){return sa.utf8Write(a,b,4294967295)}:!!(ja&&ja.encodeInto)&&function(a,b){return ja.encodeInto(a,sa.subarray(b)).written},h=this;a||(a={});let i=a&&a.sequential,j=a.structures||a.saveStructures,k=a.maxSharedStructures;if(null==k&&(k=j?32:0),8160<k)throw new Error("Maximum maxSharedStructure is 8160");a.structuredClone&&null==a.moreTypes&&(a.moreTypes=!0);let l=a.maxOwnStructures;null==l&&(l=j?32:64),this.structures||!1==a.useRecords||(this.structures=[]);// two byte record ids for shared structures
let m=32<k||64<l+k,n=k+64,o=k+l+64;if(8256<o)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let p=[],q=0,r=0;this.pack=this.encode=function(a,g){if(sa||(sa=new pa(8192),ua=new DataView(sa.buffer,0,8192),wa=0),va=sa.length-10,2048>va-wa?(sa=new pa(sa.length),ua=new DataView(sa.buffer,0,sa.length),va=sa.length-10,wa=0):wa=2147483640&wa+7,b=wa,e=h.structuredClone?new Map:null,h.bundleStrings&&"string"!=typeof a?(xa=[],xa.size=1/0):xa=null,d=h.structures,d){d.uninitialized&&(d=h._mergeStructures(h.getStructures()));let a=d.sharedLength||0;if(a>k)//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+d.sharedLength);if(!d.transitions){d.transitions=Object.create(null);for(let b,c=0;c<a;c++){if(b=d[c],!b)continue;let a,e=d.transitions;for(let c,d=0,f=b.length;d<f;d++)c=b[d],a=e[c],a||(a=e[c]=Object.create(null)),e=a;e[ya]=c+64}f=a}i||(d.nextId=a+64)}c&&(c=!1);try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(s(a),xa&&x(b,s),h.offset=wa,e&&e.idsToInsert){wa+=6*e.idsToInsert.length,wa>va&&u(wa),h.offset=wa;let a=w(sa.subarray(b,wa),e.idsToInsert);return e=null,a}return g&Ha?(sa.start=b,sa.end=wa,sa):sa.subarray(b,wa);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(d){10>r&&r++;let e=d.sharedLength||k;if(d.length>e&&(d.length=e),1e4<q)d.transitions=null,r=0,q=0,0<p.length&&(p=[]);else if(0<p.length&&!i){for(let a=0,b=p.length;a<b;a++)p[a][ya]=0;p=[]}if(c&&h.saveStructures){// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let c=sa.subarray(b,wa);return!1===h.saveStructures(d,f)?(h._mergeStructures(h.getStructures()),h.pack(a)):(f=e,c)}}g&Ia&&(wa=b)}};const s=a=>{wa>va&&(sa=u(wa));var c,d=typeof a;if("string"==d){let d=a.length;if(xa&&4<=d&&4096>d){if((xa.size+=d)>61440){let a,c=(xa[0]?3*xa[0].length+xa[1].length:0)+10;wa+c>va&&(sa=u(wa+c)),xa.position?(sa[wa]=200,wa+=3,sa[wa++]=98,a=wa-b,wa+=4,x(b,s),ua.setUint16(a+b-3,wa-b-a)):(sa[wa++]=214,sa[wa++]=98,a=wa-b,wa+=4),xa=["",""],xa.size=0,xa.position=a}let c=/[\u0080-\uFFFF]/.test(a);return xa[c?0:1]+=a,sa[wa++]=193,void s(c?-d:d)}let e=32>d?1:256>d?2:65536>d?3:5;// first we estimate the header size, so we can write to the correct location
let f=3*d;if(wa+f>va&&(sa=u(wa+f)),64>d||!g){let b,f,g,h=wa+e;for(b=0;b<d;b++)f=a.charCodeAt(b),128>f?sa[h++]=f:2048>f?(sa[h++]=192|f>>6,sa[h++]=128|63&f):55296==(64512&f)&&56320==(64512&(g=a.charCodeAt(b+1)))?(f=65536+((1023&f)<<10)+(1023&g),b++,sa[h++]=240|f>>18,sa[h++]=128|63&f>>12,sa[h++]=128|63&f>>6,sa[h++]=128|63&f):(sa[h++]=224|f>>12,sa[h++]=128|63&f>>6,sa[h++]=128|63&f);c=h-wa-e}else c=g(a,wa+e);32>c?sa[wa++]=160|c:256>c?(2>e&&sa.copyWithin(wa+2,wa+1,wa+1+c),sa[wa++]=217,sa[wa++]=c):65536>c?(3>e&&sa.copyWithin(wa+3,wa+2,wa+2+c),sa[wa++]=218,sa[wa++]=c>>8,sa[wa++]=255&c):(5>e&&sa.copyWithin(wa+5,wa+3,wa+3+c),sa[wa++]=219,ua.setUint32(wa,c),wa+=4),wa+=c}else if("number"===d){if(a>>>0===a)64>a||128>a&&!1===this.useRecords?sa[wa++]=a:256>a?(sa[wa++]=204,sa[wa++]=a):65536>a?(sa[wa++]=205,sa[wa++]=a>>8,sa[wa++]=255&a):(sa[wa++]=206,ua.setUint32(wa,a),wa+=4);else if(a>>0===a)-32<=a?sa[wa++]=256+a:-128<=a?(sa[wa++]=208,sa[wa++]=a+256):-32768<=a?(sa[wa++]=209,ua.setInt16(wa,a),wa+=2):(sa[wa++]=210,ua.setInt32(wa,a),wa+=4);else{let b;if(0<(b=this.useFloat32)&&4294967296>a&&-2147483648<=a){sa[wa++]=202,ua.setFloat32(wa,a);let c;if(4>b||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(c=a*da[(127&sa[wa])<<1|sa[wa+1]>>7])>>0===c)return void(wa+=4);// move back into position for writing a double
wa--}sa[wa++]=203,ua.setFloat64(wa,a),wa+=8}}else if("object"===d){if(!a)sa[wa++]=192;else{if(e){let c=e.get(a);if(c){if(!c.id){let a=e.idsToInsert||(e.idsToInsert=[]);c.id=a.push(c)}return sa[wa++]=214,sa[wa++]=112,ua.setUint32(wa,c.id),void(wa+=4)}e.set(a,{offset:wa-b})}let d=a.constructor;if(d===Object)t(a,!0);else if(d===Array){c=a.length,16>c?sa[wa++]=144|c:65536>c?(sa[wa++]=220,sa[wa++]=c>>8,sa[wa++]=255&c):(sa[wa++]=221,ua.setUint32(wa,c),wa+=4);for(let b=0;b<c;b++)s(a[b])}else if(d===Map){c=a.size,16>c?sa[wa++]=128|c:65536>c?(sa[wa++]=222,sa[wa++]=c>>8,sa[wa++]=255&c):(sa[wa++]=223,ua.setUint32(wa,c),wa+=4);for(let[b,c]of a)s(b),s(c)}else{for(let b,c=0,d=ma.length;c<d;c++)if(b=na[c],a instanceof b){let b=ma[c];if(b.write)return b.type&&(sa[wa++]=212,sa[wa++]=b.type,sa[wa++]=0),void s(b.write.call(this,a));let d=sa,e=ua,f=wa;sa=null;let g;try{g=b.pack.call(this,a,a=>(sa=d,d=null,wa+=a,wa>va&&u(wa),{target:sa,targetView:ua,position:wa-a}),s)}finally{d&&(sa=d,ua=e,wa=f,va=sa.length-10)}return void(g&&(g.length+wa>va&&u(g.length+wa),wa=v(g,sa,wa,b.type)))}// no extension found, write as object
t(a,!a.hasOwnProperty)}}}else if("boolean"===d)sa[wa++]=a?195:194;else if("bigint"===d){if(a<BigInt(1)<<BigInt(63)&&a>=-(BigInt(1)<<BigInt(63)))sa[wa++]=211,ua.setBigInt64(wa,a);else if(a<BigInt(1)<<BigInt(64)&&0<a)sa[wa++]=207,ua.setBigUint64(wa,a);else// overflow
if(this.largeBigIntToFloat)sa[wa++]=203,ua.setFloat64(wa,+a);else throw new RangeError(a+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");wa+=8}else if("undefined"===d)this.encodeUndefinedAsNil?sa[wa++]=192:(sa[wa++]=212,sa[wa++]=0,sa[wa++]=0);else if("function"===d)s(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+d)},t=!1===this.useRecords?this.variableMapSize?a=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let b=Object.keys(a),c=b.length;16>c?sa[wa++]=128|c:65536>c?(sa[wa++]=222,sa[wa++]=c>>8,sa[wa++]=255&c):(sa[wa++]=223,ua.setUint32(wa,c),wa+=4);let d;for(let e=0;e<c;e++)s(d=b[e]),s(a[d])}:(a,c)=>{sa[wa++]=222;// always using map 16, so we can preallocate and set the length afterwards
let d=wa-b;wa+=2;let e=0;for(let b in a)(c||a.hasOwnProperty(b))&&(s(b),s(a[b]),e++);sa[d++ +b]=e>>8,sa[d+b]=255&e}:a.progressiveRecords&&!m?// this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
(a,c)=>{let e,f,g=d.transitions||(d.transitions=Object.create(null)),h=wa++-b;for(let i in a)if(c||a.hasOwnProperty(i)){if(e=g[i],e)g=e;else{// record doesn't exist, create full new record and insert it
let c=Object.keys(a),j=g;g=d.transitions;let k=0;for(let a,b=0,d=c.length;b<d;b++)a=c[b],e=g[a],e||(e=g[a]=Object.create(null),k++),g=e;h+b+1==wa?(wa--,y(g,c,k)):// otherwise we need to insert the record, moving existing data after the record
z(g,c,h,k),f=!0,g=j[i]}s(a[i])}if(!f){let c=g[ya];c?sa[h+b]=c:z(g,Object.keys(a),h,0)}}:(a,b)=>{let c,e=d.transitions||(d.transitions=Object.create(null)),f=0;for(let d in a)(b||a.hasOwnProperty(d))&&(c=e[d],c||(c=e[d]=Object.create(null),f++),e=c);let g=e[ya];// now write the values
for(let c in g?96<=g&&m?(sa[wa++]=(31&(g-=96))+96,sa[wa++]=g>>5):sa[wa++]=g:y(e,e.__keys__||Object.keys(a),f),a)(b||a.hasOwnProperty(c))&&s(a[c])},u=a=>{var c=Math.min,d=Math.round,e=Math.max;let f;if(16777216<a){// special handling for really large buffers
if(a-b>ra)throw new Error("Packed buffer would be larger than maximum buffer size");f=c(ra,4096*d(e((a-b)*(67108864<a?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
f=(e(a-b<<2,sa.length-1)>>12)+1<<12;let g=new pa(f);return ua=new DataView(g.buffer,0,f),a=c(a,sa.length),sa.copy?sa.copy(g,0,b,a):g.set(sa.slice(b,a)),wa-=b,b=0,va=g.length-10,sa=g},y=(a,b,e)=>{let f=d.nextId;f||(f=64),f<n&&this.shouldShareStructure&&!this.shouldShareStructure(b)?(f=d.nextOwnId,!(f<o)&&(f=n),d.nextOwnId=f+1):(f>=o&&(// cycle back around
f=n),d.nextId=f+1);let g=b.highByte=96<=f&&m?f-96>>5:-1;a[ya]=f,a.__keys__=b,d[f-64]=b,f<n?(b.isShared=!0,d.sharedLength=f-63,c=!0,0<=g?(sa[wa++]=(31&f)+96,sa[wa++]=g):sa[wa++]=f):(0<=g?(sa[wa++]=213,sa[wa++]=114,sa[wa++]=(31&f)+96,sa[wa++]=g):(sa[wa++]=212,sa[wa++]=114,sa[wa++]=f),e&&(q+=r*e),p.length>=l&&(p.shift()[ya]=0),p.push(a),s(b))},z=(a,c,d,e)=>{let f=sa,g=wa,h=va,i=b;sa=ta,wa=0,b=0,sa||(ta=sa=new pa(8192)),va=sa.length-10,y(a,c,e),ta=sa;let j=wa;if(sa=f,wa=g,va=h,b=i,1<j){let a=wa+j-1;a>va&&u(a);let c=d+b;sa.copyWithin(c+j,c+1,wa),sa.set(ta.slice(0,j),c),wa=a}else sa[d+b]=ta[0]}}useBuffer(a){// this means we are finished using our own buffer and we can write over it safely
sa=a,ua=new DataView(sa.buffer,sa.byteOffset,sa.byteLength),wa=0}clearSharedData(){this.structures&&(this.structures=[])}}na=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,P],ma=[{pack(a,c,d){let e=a.getTime()/1e3;if((this.useTimestamp32||0===a.getMilliseconds())&&0<=e&&4294967296>e){// Timestamp 32
let{target:a,targetView:b,position:d}=c(6);a[d++]=214,a[d++]=255,b.setUint32(d,e)}else if(0<e&&4294967296>e){// Timestamp 64
let{target:b,targetView:d,position:f}=c(10);b[f++]=215,b[f++]=255,d.setUint32(f,4e6*a.getMilliseconds()+(e/1e3/4294967296>>0)),d.setUint32(f+4,e)}else if(isNaN(e)){if(this.onInvalidDate)return c(0),d(this.onInvalidDate());// Intentionally invalid timestamp
let{target:a,targetView:b,position:e}=c(3);a[e++]=212,a[e++]=255,a[e++]=255}else{// Timestamp 96
let{target:d,targetView:f,position:g}=c(15);d[g++]=199,d[g++]=12,d[g++]=255,f.setUint32(g,1e6*a.getMilliseconds()),f.setBigInt64(g+4,BigInt(b(e)))}}},{pack(a,b,c){let d=Array.from(a),{target:e,position:f}=b(this.moreTypes?3:0);this.moreTypes&&(e[f++]=212,e[f++]=115,e[f++]=0),c(d)}},{pack(a,b,c){let{target:d,position:e}=b(this.moreTypes?3:0);this.moreTypes&&(d[e++]=212,d[e++]=101,d[e++]=0),c([a.name,a.message])}},{pack(a,b,c){let{target:d,position:e}=b(this.moreTypes?3:0);this.moreTypes&&(d[e++]=212,d[e++]=120,d[e++]=0),c([a.source,a.flags])}},{pack(a,b){this.moreTypes?t(a,16,b):u(oa?Buffer.from(a):new Uint8Array(a),b)}},{pack(a,b){let c=a.constructor;c!==qa&&this.moreTypes?t(a,ba.indexOf(c.name),b):u(a,b)}},{pack(a,b){// specific 0xC1 object
let{target:c,position:d}=b(1);c[d]=193}}];let Aa=new za({useRecords:!1});const Ba=Aa.pack,Ca=Aa.pack,{NEVER:Da,ALWAYS:Ea,DECIMAL_ROUND:Fa,DECIMAL_FIT:Ga}=ia,Ha=512,Ia=1024;a.ALWAYS=Ea,a.C1=Q,a.DECIMAL_FIT=Ga,a.DECIMAL_ROUND=Fa,a.Decoder=T,a.Encoder=za,a.FLOAT32_OPTIONS=ia,a.NEVER=Da,a.Packr=za,a.REUSE_BUFFER_MODE=Ha,a.Unpackr=T,a.addExtension=y,a.clearSource=r,a.decode=ha,a.decodeIter=function(a,b={}){if(!a||"object"!=typeof a)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const c=new T(b);let d;const e=a=>{let b;// if there's incomplete data from previous chunk, concatinate and try again
d&&(a=Buffer.concat([d,a]),d=void 0);try{b=c.unpackMultiple(a)}catch(c){if(c.incomplete)d=a.slice(c.lastPosition),b=c.values;else throw c}return b};if("function"==typeof a[Symbol.iterator])return function*(){for(const b of a)yield*e(b)}();return"function"==typeof a[Symbol.asyncIterator]?async function*(){for await(const b of a)yield*e(b)}():void 0},a.encode=Ca,a.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - msgpackr pack options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(a,b={}){if(!a||"object"!=typeof a)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof a[Symbol.iterator])return z(a,b);if("function"==typeof a.then||"function"==typeof a[Symbol.asyncIterator])return A(a,b);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},a.isNativeAccelerationEnabled=!1,a.mapsAsObjects=!0,a.pack=Ba,a.roundFloat32=function(a){ka[0]=a;let b=da[(127&la[3])<<1|la[2]>>7];return(b*a+(0<a?.5:-.5)>>0)/b},a.unpack=fa,a.unpackMultiple=ga,a.useRecords=!1,Object.defineProperty(a,"__esModule",{value:!0})});
